// WARNING: Please don't edit this file. It was generated by C++/WinRT v1.0.180821.2

#pragma once

WINRT_EXPORT namespace winrt::Windows::Storage {

struct StorageFile;

}

WINRT_EXPORT namespace winrt::Windows::Storage::Streams {

struct DataReader;
struct DataWriter;

}

WINRT_EXPORT namespace winrt::Windows::UI::Xaml::Data {

struct PropertyChangedEventHandler;

}

WINRT_EXPORT namespace winrt::QGL_Projection {

struct ICompilerVersion;
struct ICompilerVersionFactory;
struct ICompilerVersionStatics;
struct IContentExtension;
struct IContentInfo;
struct IContentInfoStatics;
struct IContentLoader;
struct IContentLoaderFactory;
struct IContentProject;
struct IContentProjectEntry;
struct IContentProjectEntryFactory;
struct IResourceType;
struct IResourceTypeFactory;
struct CompilerVersion;
struct ContentInfo;
struct ContentLoader;
struct ContentProject;
struct ContentProjectEntry;
struct ResourceType;

}

namespace winrt::impl {

template <> struct category<QGL_Projection::ICompilerVersion>{ using type = interface_category; };
template <> struct category<QGL_Projection::ICompilerVersionFactory>{ using type = interface_category; };
template <> struct category<QGL_Projection::ICompilerVersionStatics>{ using type = interface_category; };
template <> struct category<QGL_Projection::IContentExtension>{ using type = interface_category; };
template <> struct category<QGL_Projection::IContentInfo>{ using type = interface_category; };
template <> struct category<QGL_Projection::IContentInfoStatics>{ using type = interface_category; };
template <> struct category<QGL_Projection::IContentLoader>{ using type = interface_category; };
template <> struct category<QGL_Projection::IContentLoaderFactory>{ using type = interface_category; };
template <> struct category<QGL_Projection::IContentProject>{ using type = interface_category; };
template <> struct category<QGL_Projection::IContentProjectEntry>{ using type = interface_category; };
template <> struct category<QGL_Projection::IContentProjectEntryFactory>{ using type = interface_category; };
template <> struct category<QGL_Projection::IResourceType>{ using type = interface_category; };
template <> struct category<QGL_Projection::IResourceTypeFactory>{ using type = interface_category; };
template <> struct category<QGL_Projection::CompilerVersion>{ using type = class_category; };
template <> struct category<QGL_Projection::ContentInfo>{ using type = class_category; };
template <> struct category<QGL_Projection::ContentLoader>{ using type = class_category; };
template <> struct category<QGL_Projection::ContentProject>{ using type = class_category; };
template <> struct category<QGL_Projection::ContentProjectEntry>{ using type = class_category; };
template <> struct category<QGL_Projection::ResourceType>{ using type = class_category; };
template <> struct name<QGL_Projection::ICompilerVersion>{ static constexpr auto & value{ L"QGL_Projection.ICompilerVersion" }; };
template <> struct name<QGL_Projection::ICompilerVersionFactory>{ static constexpr auto & value{ L"QGL_Projection.ICompilerVersionFactory" }; };
template <> struct name<QGL_Projection::ICompilerVersionStatics>{ static constexpr auto & value{ L"QGL_Projection.ICompilerVersionStatics" }; };
template <> struct name<QGL_Projection::IContentExtension>{ static constexpr auto & value{ L"QGL_Projection.IContentExtension" }; };
template <> struct name<QGL_Projection::IContentInfo>{ static constexpr auto & value{ L"QGL_Projection.IContentInfo" }; };
template <> struct name<QGL_Projection::IContentInfoStatics>{ static constexpr auto & value{ L"QGL_Projection.IContentInfoStatics" }; };
template <> struct name<QGL_Projection::IContentLoader>{ static constexpr auto & value{ L"QGL_Projection.IContentLoader" }; };
template <> struct name<QGL_Projection::IContentLoaderFactory>{ static constexpr auto & value{ L"QGL_Projection.IContentLoaderFactory" }; };
template <> struct name<QGL_Projection::IContentProject>{ static constexpr auto & value{ L"QGL_Projection.IContentProject" }; };
template <> struct name<QGL_Projection::IContentProjectEntry>{ static constexpr auto & value{ L"QGL_Projection.IContentProjectEntry" }; };
template <> struct name<QGL_Projection::IContentProjectEntryFactory>{ static constexpr auto & value{ L"QGL_Projection.IContentProjectEntryFactory" }; };
template <> struct name<QGL_Projection::IResourceType>{ static constexpr auto & value{ L"QGL_Projection.IResourceType" }; };
template <> struct name<QGL_Projection::IResourceTypeFactory>{ static constexpr auto & value{ L"QGL_Projection.IResourceTypeFactory" }; };
template <> struct name<QGL_Projection::CompilerVersion>{ static constexpr auto & value{ L"QGL_Projection.CompilerVersion" }; };
template <> struct name<QGL_Projection::ContentInfo>{ static constexpr auto & value{ L"QGL_Projection.ContentInfo" }; };
template <> struct name<QGL_Projection::ContentLoader>{ static constexpr auto & value{ L"QGL_Projection.ContentLoader" }; };
template <> struct name<QGL_Projection::ContentProject>{ static constexpr auto & value{ L"QGL_Projection.ContentProject" }; };
template <> struct name<QGL_Projection::ContentProjectEntry>{ static constexpr auto & value{ L"QGL_Projection.ContentProjectEntry" }; };
template <> struct name<QGL_Projection::ResourceType>{ static constexpr auto & value{ L"QGL_Projection.ResourceType" }; };
template <> struct guid_storage<QGL_Projection::ICompilerVersion>{ static constexpr guid value{ 0x4A19C4DF,0x0910,0x5D72,{ 0x9E,0xE5,0x60,0x00,0xE6,0x56,0x23,0xF5 } }; };
template <> struct guid_storage<QGL_Projection::ICompilerVersionFactory>{ static constexpr guid value{ 0x003D485D,0x499D,0x5D3C,{ 0x9E,0x21,0x5F,0x42,0x65,0xBE,0x47,0x57 } }; };
template <> struct guid_storage<QGL_Projection::ICompilerVersionStatics>{ static constexpr guid value{ 0xDCEAFF11,0xDB3D,0x51DF,{ 0x98,0x04,0x1B,0x4A,0xC7,0x11,0xEC,0x83 } }; };
template <> struct guid_storage<QGL_Projection::IContentExtension>{ static constexpr guid value{ 0xC115F115,0xA39A,0x5849,{ 0x96,0xBD,0x51,0x06,0x4F,0x9F,0x17,0x9A } }; };
template <> struct guid_storage<QGL_Projection::IContentInfo>{ static constexpr guid value{ 0xF0B1ADA2,0x7BF0,0x5E50,{ 0x87,0x10,0xF6,0x27,0x80,0x51,0x0B,0x85 } }; };
template <> struct guid_storage<QGL_Projection::IContentInfoStatics>{ static constexpr guid value{ 0xB85CA99F,0x4936,0x5A87,{ 0x97,0xED,0xED,0xD4,0x3B,0xC3,0x0D,0xFB } }; };
template <> struct guid_storage<QGL_Projection::IContentLoader>{ static constexpr guid value{ 0xB8A4EFE6,0x3720,0x5A38,{ 0xB4,0x6A,0x35,0x84,0x19,0xA9,0x35,0x35 } }; };
template <> struct guid_storage<QGL_Projection::IContentLoaderFactory>{ static constexpr guid value{ 0xC26C11EA,0x9FCF,0x5445,{ 0x99,0x6E,0x16,0x87,0xF7,0x67,0xCF,0xE9 } }; };
template <> struct guid_storage<QGL_Projection::IContentProject>{ static constexpr guid value{ 0x68EF91C8,0x1657,0x52E9,{ 0xB9,0x26,0xE6,0x3E,0x2E,0x08,0xD8,0x4C } }; };
template <> struct guid_storage<QGL_Projection::IContentProjectEntry>{ static constexpr guid value{ 0x79764AAD,0x4222,0x52B6,{ 0x84,0x9A,0xA8,0xCA,0xDA,0x16,0xD6,0xD7 } }; };
template <> struct guid_storage<QGL_Projection::IContentProjectEntryFactory>{ static constexpr guid value{ 0x688EC4E3,0xFA81,0x53B9,{ 0x97,0xDC,0xE7,0x73,0xD2,0xDE,0xBA,0xDF } }; };
template <> struct guid_storage<QGL_Projection::IResourceType>{ static constexpr guid value{ 0xA671FFD5,0x2D47,0x5639,{ 0x94,0x2A,0x4F,0x1A,0x07,0x0A,0xEC,0x0B } }; };
template <> struct guid_storage<QGL_Projection::IResourceTypeFactory>{ static constexpr guid value{ 0xA2D9383B,0x72E6,0x5C12,{ 0x95,0xEC,0xA9,0x3E,0x8A,0xFD,0x0F,0x7A } }; };
template <> struct default_interface<QGL_Projection::CompilerVersion>{ using type = QGL_Projection::ICompilerVersion; };
template <> struct default_interface<QGL_Projection::ContentInfo>{ using type = QGL_Projection::IContentInfo; };
template <> struct default_interface<QGL_Projection::ContentLoader>{ using type = QGL_Projection::IContentLoader; };
template <> struct default_interface<QGL_Projection::ContentProject>{ using type = QGL_Projection::IContentProject; };
template <> struct default_interface<QGL_Projection::ContentProjectEntry>{ using type = QGL_Projection::IContentProjectEntry; };
template <> struct default_interface<QGL_Projection::ResourceType>{ using type = QGL_Projection::IResourceType; };

template <> struct abi<QGL_Projection::ICompilerVersion>{ struct type : IInspectable
{
    virtual int32_t WINRT_CALL get_Value(uint32_t* value) noexcept = 0;
    virtual int32_t WINRT_CALL get_ValueName(void** value) noexcept = 0;
};};

template <> struct abi<QGL_Projection::ICompilerVersionFactory>{ struct type : IInspectable
{
    virtual int32_t WINRT_CALL CreateInstance(uint32_t val, void** value) noexcept = 0;
};};

template <> struct abi<QGL_Projection::ICompilerVersionStatics>{ struct type : IInspectable
{
    virtual int32_t WINRT_CALL get_Version_0_1(void** value) noexcept = 0;
    virtual int32_t WINRT_CALL get_Version_0_2(void** value) noexcept = 0;
    virtual int32_t WINRT_CALL get_CompilerVersions(void** value) noexcept = 0;
    virtual int32_t WINRT_CALL get_ObservableCompilerVersions(void** value) noexcept = 0;
};};

template <> struct abi<QGL_Projection::IContentExtension>{ struct type : IInspectable
{
    virtual int32_t WINRT_CALL get_ResourceType(uint16_t* value) noexcept = 0;
    virtual int32_t WINRT_CALL get_ContentLoaderID(uint16_t* value) noexcept = 0;
    virtual int32_t WINRT_CALL get_ContentExtension(void** value) noexcept = 0;
    virtual int32_t WINRT_CALL get_ContentLoaderName(void** value) noexcept = 0;
    virtual int32_t WINRT_CALL get_ResourceTypeName(void** value) noexcept = 0;
    virtual int32_t WINRT_CALL Open(void* f, void** operation) noexcept = 0;
    virtual int32_t WINRT_CALL Save(void* f, void** operation) noexcept = 0;
};};

template <> struct abi<QGL_Projection::IContentInfo>{ struct type : IInspectable
{
    virtual int32_t WINRT_CALL get_ContentVisible(bool* value) noexcept = 0;
    virtual int32_t WINRT_CALL put_ContentVisible(bool value) noexcept = 0;
    virtual int32_t WINRT_CALL get_ContentObeyPhysics(bool* value) noexcept = 0;
    virtual int32_t WINRT_CALL put_ContentObeyPhysics(bool value) noexcept = 0;
    virtual int32_t WINRT_CALL get_ContentName(void** value) noexcept = 0;
    virtual int32_t WINRT_CALL put_ContentName(void* value) noexcept = 0;
    virtual int32_t WINRT_CALL get_ResourceType(void** value) noexcept = 0;
    virtual int32_t WINRT_CALL put_ResourceType(void* value) noexcept = 0;
    virtual int32_t WINRT_CALL get_ContentLoader(void** value) noexcept = 0;
    virtual int32_t WINRT_CALL put_ContentLoader(void* value) noexcept = 0;
    virtual int32_t WINRT_CALL get_CompilerVersion(void** value) noexcept = 0;
    virtual int32_t WINRT_CALL put_CompilerVersion(void* value) noexcept = 0;
    virtual int32_t WINRT_CALL Guid(winrt::guid* result) noexcept = 0;
    virtual int32_t WINRT_CALL Guid2(winrt::guid g) noexcept = 0;
};};

template <> struct abi<QGL_Projection::IContentInfoStatics>{ struct type : IInspectable
{
    virtual int32_t WINRT_CALL WriteContentInfoToBuffer(void* info, void* r) noexcept = 0;
    virtual int32_t WINRT_CALL ReadContentInfoFromBuffer(void* r, void* supportedResourceTypes, void** result) noexcept = 0;
};};

template <> struct abi<QGL_Projection::IContentLoader>{ struct type : IInspectable
{
    virtual int32_t WINRT_CALL get_Value(uint16_t* value) noexcept = 0;
    virtual int32_t WINRT_CALL get_ValueName(void** value) noexcept = 0;
};};

template <> struct abi<QGL_Projection::IContentLoaderFactory>{ struct type : IInspectable
{
    virtual int32_t WINRT_CALL CreateInstance(uint16_t val, void* name, void** value) noexcept = 0;
};};

template <> struct abi<QGL_Projection::IContentProject>{ struct type : IInspectable
{
    virtual int32_t WINRT_CALL get_ContentInfo(void** value) noexcept = 0;
    virtual int32_t WINRT_CALL put_ContentInfo(void* value) noexcept = 0;
    virtual int32_t WINRT_CALL get_ObservableEntries(void** value) noexcept = 0;
    virtual int32_t WINRT_CALL put_ObservableEntries(void* value) noexcept = 0;
    virtual int32_t WINRT_CALL LoadFromFileAsync(void* f, void* supported, void** operation) noexcept = 0;
    virtual int32_t WINRT_CALL SaveToFileAsync(void* f, void** operation) noexcept = 0;
};};

template <> struct abi<QGL_Projection::IContentProjectEntry>{ struct type : IInspectable
{
    virtual int32_t WINRT_CALL get_ContentInfo(void** value) noexcept = 0;
    virtual int32_t WINRT_CALL put_ContentInfo(void* value) noexcept = 0;
    virtual int32_t WINRT_CALL get_FilePath(void** value) noexcept = 0;
    virtual int32_t WINRT_CALL ChangeFile(void* newFile, void** operation) noexcept = 0;
};};

template <> struct abi<QGL_Projection::IContentProjectEntryFactory>{ struct type : IInspectable
{
    virtual int32_t WINRT_CALL CreateInstance(void* filePath, void* info, void** value) noexcept = 0;
};};

template <> struct abi<QGL_Projection::IResourceType>{ struct type : IInspectable
{
    virtual int32_t WINRT_CALL get_Value(uint16_t* value) noexcept = 0;
    virtual int32_t WINRT_CALL get_ValueName(void** value) noexcept = 0;
    virtual int32_t WINRT_CALL get_Loaders(void** value) noexcept = 0;
    virtual int32_t WINRT_CALL get_ObservableLoaders(void** value) noexcept = 0;
};};

template <> struct abi<QGL_Projection::IResourceTypeFactory>{ struct type : IInspectable
{
    virtual int32_t WINRT_CALL CreateInstance(uint16_t val, void* name, uint32_t __loadersSize, void** loaders, void** value) noexcept = 0;
};};

template <typename D>
struct consume_QGL_Projection_ICompilerVersion
{
    uint32_t Value() const;
    hstring ValueName() const;
};
template <> struct consume<QGL_Projection::ICompilerVersion> { template <typename D> using type = consume_QGL_Projection_ICompilerVersion<D>; };

template <typename D>
struct consume_QGL_Projection_ICompilerVersionFactory
{
    QGL_Projection::CompilerVersion CreateInstance(uint32_t val) const;
};
template <> struct consume<QGL_Projection::ICompilerVersionFactory> { template <typename D> using type = consume_QGL_Projection_ICompilerVersionFactory<D>; };

template <typename D>
struct consume_QGL_Projection_ICompilerVersionStatics
{
    QGL_Projection::CompilerVersion Version_0_1() const;
    QGL_Projection::CompilerVersion Version_0_2() const;
    Windows::Foundation::Collections::IVector<QGL_Projection::CompilerVersion> CompilerVersions() const;
    Windows::Foundation::Collections::IObservableVector<Windows::Foundation::IInspectable> ObservableCompilerVersions() const;
};
template <> struct consume<QGL_Projection::ICompilerVersionStatics> { template <typename D> using type = consume_QGL_Projection_ICompilerVersionStatics<D>; };

template <typename D>
struct consume_QGL_Projection_IContentExtension
{
    uint16_t ResourceType() const;
    uint16_t ContentLoaderID() const;
    hstring ContentExtension() const;
    hstring ContentLoaderName() const;
    hstring ResourceTypeName() const;
    Windows::Foundation::IAsyncAction Open(Windows::Storage::StorageFile const& f) const;
    Windows::Foundation::IAsyncAction Save(Windows::Storage::StorageFile const& f) const;
};
template <> struct consume<QGL_Projection::IContentExtension> { template <typename D> using type = consume_QGL_Projection_IContentExtension<D>; };

template <typename D>
struct consume_QGL_Projection_IContentInfo
{
    bool ContentVisible() const;
    void ContentVisible(bool value) const;
    bool ContentObeyPhysics() const;
    void ContentObeyPhysics(bool value) const;
    hstring ContentName() const;
    void ContentName(param::hstring const& value) const;
    QGL_Projection::ResourceType ResourceType() const;
    void ResourceType(QGL_Projection::ResourceType const& value) const;
    QGL_Projection::ContentLoader ContentLoader() const;
    void ContentLoader(QGL_Projection::ContentLoader const& value) const;
    QGL_Projection::CompilerVersion CompilerVersion() const;
    void CompilerVersion(QGL_Projection::CompilerVersion const& value) const;
    winrt::guid Guid() const;
    void Guid(winrt::guid const& g) const;
};
template <> struct consume<QGL_Projection::IContentInfo> { template <typename D> using type = consume_QGL_Projection_IContentInfo<D>; };

template <typename D>
struct consume_QGL_Projection_IContentInfoStatics
{
    void WriteContentInfoToBuffer(QGL_Projection::ContentInfo const& info, Windows::Storage::Streams::DataWriter const& r) const;
    QGL_Projection::ContentInfo ReadContentInfoFromBuffer(Windows::Storage::Streams::DataReader const& r, param::vector<QGL_Projection::ResourceType> const& supportedResourceTypes) const;
};
template <> struct consume<QGL_Projection::IContentInfoStatics> { template <typename D> using type = consume_QGL_Projection_IContentInfoStatics<D>; };

template <typename D>
struct consume_QGL_Projection_IContentLoader
{
    uint16_t Value() const;
    hstring ValueName() const;
};
template <> struct consume<QGL_Projection::IContentLoader> { template <typename D> using type = consume_QGL_Projection_IContentLoader<D>; };

template <typename D>
struct consume_QGL_Projection_IContentLoaderFactory
{
    QGL_Projection::ContentLoader CreateInstance(uint16_t val, param::hstring const& name) const;
};
template <> struct consume<QGL_Projection::IContentLoaderFactory> { template <typename D> using type = consume_QGL_Projection_IContentLoaderFactory<D>; };

template <typename D>
struct consume_QGL_Projection_IContentProject
{
    QGL_Projection::ContentInfo ContentInfo() const;
    void ContentInfo(QGL_Projection::ContentInfo const& value) const;
    Windows::Foundation::Collections::IObservableVector<Windows::Foundation::IInspectable> ObservableEntries() const;
    void ObservableEntries(Windows::Foundation::Collections::IObservableVector<Windows::Foundation::IInspectable> const& value) const;
    Windows::Foundation::IAsyncOperation<bool> LoadFromFileAsync(Windows::Storage::StorageFile const& f, param::vector<QGL_Projection::ResourceType> const& supported) const;
    Windows::Foundation::IAsyncOperation<bool> SaveToFileAsync(Windows::Storage::StorageFile const& f) const;
};
template <> struct consume<QGL_Projection::IContentProject> { template <typename D> using type = consume_QGL_Projection_IContentProject<D>; };

template <typename D>
struct consume_QGL_Projection_IContentProjectEntry
{
    QGL_Projection::ContentInfo ContentInfo() const;
    void ContentInfo(QGL_Projection::ContentInfo const& value) const;
    hstring FilePath() const;
    Windows::Foundation::IAsyncAction ChangeFile(Windows::Storage::StorageFile const& newFile) const;
};
template <> struct consume<QGL_Projection::IContentProjectEntry> { template <typename D> using type = consume_QGL_Projection_IContentProjectEntry<D>; };

template <typename D>
struct consume_QGL_Projection_IContentProjectEntryFactory
{
    QGL_Projection::ContentProjectEntry CreateInstance(param::hstring const& filePath, QGL_Projection::ContentInfo const& info) const;
};
template <> struct consume<QGL_Projection::IContentProjectEntryFactory> { template <typename D> using type = consume_QGL_Projection_IContentProjectEntryFactory<D>; };

template <typename D>
struct consume_QGL_Projection_IResourceType
{
    uint16_t Value() const;
    hstring ValueName() const;
    Windows::Foundation::Collections::IVector<QGL_Projection::ContentLoader> Loaders() const;
    Windows::Foundation::Collections::IObservableVector<Windows::Foundation::IInspectable> ObservableLoaders() const;
};
template <> struct consume<QGL_Projection::IResourceType> { template <typename D> using type = consume_QGL_Projection_IResourceType<D>; };

template <typename D>
struct consume_QGL_Projection_IResourceTypeFactory
{
    QGL_Projection::ResourceType CreateInstance(uint16_t val, param::hstring const& name, array_view<QGL_Projection::ContentLoader const> loaders) const;
};
template <> struct consume<QGL_Projection::IResourceTypeFactory> { template <typename D> using type = consume_QGL_Projection_IResourceTypeFactory<D>; };

}
