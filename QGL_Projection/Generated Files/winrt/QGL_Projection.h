// WARNING: Please don't edit this file. It was generated by C++/WinRT v1.0.180821.2

#pragma once

#include "winrt/base.h"


static_assert(winrt::check_version(CPPWINRT_VERSION, "1.0.180821.2"), "Mismatched component and base headers.");
#include "winrt/Windows.Foundation.h"
#include "winrt/Windows.Foundation.Collections.h"
#include "winrt/impl/Windows.Storage.2.h"
#include "winrt/impl/Windows.Storage.Streams.2.h"
#include "winrt/impl/Windows.UI.Xaml.Data.2.h"
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/QGL_Projection.2.h"

namespace winrt::impl {

template <typename D> uint32_t consume_QGL_Projection_ICompilerVersion<D>::Value() const
{
    uint32_t value{};
    check_hresult(WINRT_SHIM(QGL_Projection::ICompilerVersion)->get_Value(&value));
    return value;
}

template <typename D> hstring consume_QGL_Projection_ICompilerVersion<D>::ValueName() const
{
    hstring value{};
    check_hresult(WINRT_SHIM(QGL_Projection::ICompilerVersion)->get_ValueName(put_abi(value)));
    return value;
}

template <typename D> QGL_Projection::CompilerVersion consume_QGL_Projection_ICompilerVersionFactory<D>::CreateInstance(uint32_t val) const
{
    QGL_Projection::CompilerVersion value{ nullptr };
    check_hresult(WINRT_SHIM(QGL_Projection::ICompilerVersionFactory)->CreateInstance(val, put_abi(value)));
    return value;
}

template <typename D> QGL_Projection::CompilerVersion consume_QGL_Projection_ICompilerVersionStatics<D>::Version_0_1() const
{
    QGL_Projection::CompilerVersion value{ nullptr };
    check_hresult(WINRT_SHIM(QGL_Projection::ICompilerVersionStatics)->get_Version_0_1(put_abi(value)));
    return value;
}

template <typename D> QGL_Projection::CompilerVersion consume_QGL_Projection_ICompilerVersionStatics<D>::Version_0_2() const
{
    QGL_Projection::CompilerVersion value{ nullptr };
    check_hresult(WINRT_SHIM(QGL_Projection::ICompilerVersionStatics)->get_Version_0_2(put_abi(value)));
    return value;
}

template <typename D> Windows::Foundation::Collections::IVector<QGL_Projection::CompilerVersion> consume_QGL_Projection_ICompilerVersionStatics<D>::CompilerVersions() const
{
    Windows::Foundation::Collections::IVector<QGL_Projection::CompilerVersion> value{ nullptr };
    check_hresult(WINRT_SHIM(QGL_Projection::ICompilerVersionStatics)->get_CompilerVersions(put_abi(value)));
    return value;
}

template <typename D> Windows::Foundation::Collections::IObservableVector<Windows::Foundation::IInspectable> consume_QGL_Projection_ICompilerVersionStatics<D>::ObservableCompilerVersions() const
{
    Windows::Foundation::Collections::IObservableVector<Windows::Foundation::IInspectable> value{ nullptr };
    check_hresult(WINRT_SHIM(QGL_Projection::ICompilerVersionStatics)->get_ObservableCompilerVersions(put_abi(value)));
    return value;
}

template <typename D> uint16_t consume_QGL_Projection_IContentExtension<D>::ResourceType() const
{
    uint16_t value{};
    check_hresult(WINRT_SHIM(QGL_Projection::IContentExtension)->get_ResourceType(&value));
    return value;
}

template <typename D> uint16_t consume_QGL_Projection_IContentExtension<D>::ContentLoaderID() const
{
    uint16_t value{};
    check_hresult(WINRT_SHIM(QGL_Projection::IContentExtension)->get_ContentLoaderID(&value));
    return value;
}

template <typename D> hstring consume_QGL_Projection_IContentExtension<D>::ContentExtension() const
{
    hstring value{};
    check_hresult(WINRT_SHIM(QGL_Projection::IContentExtension)->get_ContentExtension(put_abi(value)));
    return value;
}

template <typename D> hstring consume_QGL_Projection_IContentExtension<D>::ContentLoaderName() const
{
    hstring value{};
    check_hresult(WINRT_SHIM(QGL_Projection::IContentExtension)->get_ContentLoaderName(put_abi(value)));
    return value;
}

template <typename D> hstring consume_QGL_Projection_IContentExtension<D>::ResourceTypeName() const
{
    hstring value{};
    check_hresult(WINRT_SHIM(QGL_Projection::IContentExtension)->get_ResourceTypeName(put_abi(value)));
    return value;
}

template <typename D> Windows::Foundation::IAsyncAction consume_QGL_Projection_IContentExtension<D>::Open(Windows::Storage::StorageFile const& f) const
{
    Windows::Foundation::IAsyncAction operation{ nullptr };
    check_hresult(WINRT_SHIM(QGL_Projection::IContentExtension)->Open(get_abi(f), put_abi(operation)));
    return operation;
}

template <typename D> Windows::Foundation::IAsyncAction consume_QGL_Projection_IContentExtension<D>::Save(Windows::Storage::StorageFile const& f) const
{
    Windows::Foundation::IAsyncAction operation{ nullptr };
    check_hresult(WINRT_SHIM(QGL_Projection::IContentExtension)->Save(get_abi(f), put_abi(operation)));
    return operation;
}

template <typename D> bool consume_QGL_Projection_IContentInfo<D>::ContentVisible() const
{
    bool value{};
    check_hresult(WINRT_SHIM(QGL_Projection::IContentInfo)->get_ContentVisible(&value));
    return value;
}

template <typename D> void consume_QGL_Projection_IContentInfo<D>::ContentVisible(bool value) const
{
    check_hresult(WINRT_SHIM(QGL_Projection::IContentInfo)->put_ContentVisible(value));
}

template <typename D> bool consume_QGL_Projection_IContentInfo<D>::ContentObeyPhysics() const
{
    bool value{};
    check_hresult(WINRT_SHIM(QGL_Projection::IContentInfo)->get_ContentObeyPhysics(&value));
    return value;
}

template <typename D> void consume_QGL_Projection_IContentInfo<D>::ContentObeyPhysics(bool value) const
{
    check_hresult(WINRT_SHIM(QGL_Projection::IContentInfo)->put_ContentObeyPhysics(value));
}

template <typename D> hstring consume_QGL_Projection_IContentInfo<D>::ContentName() const
{
    hstring value{};
    check_hresult(WINRT_SHIM(QGL_Projection::IContentInfo)->get_ContentName(put_abi(value)));
    return value;
}

template <typename D> void consume_QGL_Projection_IContentInfo<D>::ContentName(param::hstring const& value) const
{
    check_hresult(WINRT_SHIM(QGL_Projection::IContentInfo)->put_ContentName(get_abi(value)));
}

template <typename D> QGL_Projection::ResourceType consume_QGL_Projection_IContentInfo<D>::ResourceType() const
{
    QGL_Projection::ResourceType value{ nullptr };
    check_hresult(WINRT_SHIM(QGL_Projection::IContentInfo)->get_ResourceType(put_abi(value)));
    return value;
}

template <typename D> void consume_QGL_Projection_IContentInfo<D>::ResourceType(QGL_Projection::ResourceType const& value) const
{
    check_hresult(WINRT_SHIM(QGL_Projection::IContentInfo)->put_ResourceType(get_abi(value)));
}

template <typename D> QGL_Projection::ContentLoader consume_QGL_Projection_IContentInfo<D>::ContentLoader() const
{
    QGL_Projection::ContentLoader value{ nullptr };
    check_hresult(WINRT_SHIM(QGL_Projection::IContentInfo)->get_ContentLoader(put_abi(value)));
    return value;
}

template <typename D> void consume_QGL_Projection_IContentInfo<D>::ContentLoader(QGL_Projection::ContentLoader const& value) const
{
    check_hresult(WINRT_SHIM(QGL_Projection::IContentInfo)->put_ContentLoader(get_abi(value)));
}

template <typename D> QGL_Projection::CompilerVersion consume_QGL_Projection_IContentInfo<D>::CompilerVersion() const
{
    QGL_Projection::CompilerVersion value{ nullptr };
    check_hresult(WINRT_SHIM(QGL_Projection::IContentInfo)->get_CompilerVersion(put_abi(value)));
    return value;
}

template <typename D> void consume_QGL_Projection_IContentInfo<D>::CompilerVersion(QGL_Projection::CompilerVersion const& value) const
{
    check_hresult(WINRT_SHIM(QGL_Projection::IContentInfo)->put_CompilerVersion(get_abi(value)));
}

template <typename D> winrt::guid consume_QGL_Projection_IContentInfo<D>::Guid() const
{
    winrt::guid result{};
    check_hresult(WINRT_SHIM(QGL_Projection::IContentInfo)->Guid(put_abi(result)));
    return result;
}

template <typename D> void consume_QGL_Projection_IContentInfo<D>::Guid(winrt::guid const& g) const
{
    check_hresult(WINRT_SHIM(QGL_Projection::IContentInfo)->Guid2(get_abi(g)));
}

template <typename D> void consume_QGL_Projection_IContentInfoStatics<D>::WriteContentInfoToBuffer(QGL_Projection::ContentInfo const& info, Windows::Storage::Streams::DataWriter const& r) const
{
    check_hresult(WINRT_SHIM(QGL_Projection::IContentInfoStatics)->WriteContentInfoToBuffer(get_abi(info), get_abi(r)));
}

template <typename D> QGL_Projection::ContentInfo consume_QGL_Projection_IContentInfoStatics<D>::ReadContentInfoFromBuffer(Windows::Storage::Streams::DataReader const& r, param::vector<QGL_Projection::ResourceType> const& supportedResourceTypes) const
{
    QGL_Projection::ContentInfo result{ nullptr };
    check_hresult(WINRT_SHIM(QGL_Projection::IContentInfoStatics)->ReadContentInfoFromBuffer(get_abi(r), get_abi(supportedResourceTypes), put_abi(result)));
    return result;
}

template <typename D> uint16_t consume_QGL_Projection_IContentLoader<D>::Value() const
{
    uint16_t value{};
    check_hresult(WINRT_SHIM(QGL_Projection::IContentLoader)->get_Value(&value));
    return value;
}

template <typename D> hstring consume_QGL_Projection_IContentLoader<D>::ValueName() const
{
    hstring value{};
    check_hresult(WINRT_SHIM(QGL_Projection::IContentLoader)->get_ValueName(put_abi(value)));
    return value;
}

template <typename D> QGL_Projection::ContentLoader consume_QGL_Projection_IContentLoaderFactory<D>::CreateInstance(uint16_t val, param::hstring const& name) const
{
    QGL_Projection::ContentLoader value{ nullptr };
    check_hresult(WINRT_SHIM(QGL_Projection::IContentLoaderFactory)->CreateInstance(val, get_abi(name), put_abi(value)));
    return value;
}

template <typename D> QGL_Projection::ContentInfo consume_QGL_Projection_IContentProject<D>::ContentInfo() const
{
    QGL_Projection::ContentInfo value{ nullptr };
    check_hresult(WINRT_SHIM(QGL_Projection::IContentProject)->get_ContentInfo(put_abi(value)));
    return value;
}

template <typename D> void consume_QGL_Projection_IContentProject<D>::ContentInfo(QGL_Projection::ContentInfo const& value) const
{
    check_hresult(WINRT_SHIM(QGL_Projection::IContentProject)->put_ContentInfo(get_abi(value)));
}

template <typename D> Windows::Foundation::Collections::IObservableVector<Windows::Foundation::IInspectable> consume_QGL_Projection_IContentProject<D>::ObservableEntries() const
{
    Windows::Foundation::Collections::IObservableVector<Windows::Foundation::IInspectable> value{ nullptr };
    check_hresult(WINRT_SHIM(QGL_Projection::IContentProject)->get_ObservableEntries(put_abi(value)));
    return value;
}

template <typename D> void consume_QGL_Projection_IContentProject<D>::ObservableEntries(Windows::Foundation::Collections::IObservableVector<Windows::Foundation::IInspectable> const& value) const
{
    check_hresult(WINRT_SHIM(QGL_Projection::IContentProject)->put_ObservableEntries(get_abi(value)));
}

template <typename D> Windows::Foundation::IAsyncOperation<bool> consume_QGL_Projection_IContentProject<D>::LoadFromFileAsync(Windows::Storage::StorageFile const& f, param::vector<QGL_Projection::ResourceType> const& supported) const
{
    Windows::Foundation::IAsyncOperation<bool> operation{ nullptr };
    check_hresult(WINRT_SHIM(QGL_Projection::IContentProject)->LoadFromFileAsync(get_abi(f), get_abi(supported), put_abi(operation)));
    return operation;
}

template <typename D> Windows::Foundation::IAsyncOperation<bool> consume_QGL_Projection_IContentProject<D>::SaveToFileAsync(Windows::Storage::StorageFile const& f) const
{
    Windows::Foundation::IAsyncOperation<bool> operation{ nullptr };
    check_hresult(WINRT_SHIM(QGL_Projection::IContentProject)->SaveToFileAsync(get_abi(f), put_abi(operation)));
    return operation;
}

template <typename D> QGL_Projection::ContentInfo consume_QGL_Projection_IContentProjectEntry<D>::ContentInfo() const
{
    QGL_Projection::ContentInfo value{ nullptr };
    check_hresult(WINRT_SHIM(QGL_Projection::IContentProjectEntry)->get_ContentInfo(put_abi(value)));
    return value;
}

template <typename D> void consume_QGL_Projection_IContentProjectEntry<D>::ContentInfo(QGL_Projection::ContentInfo const& value) const
{
    check_hresult(WINRT_SHIM(QGL_Projection::IContentProjectEntry)->put_ContentInfo(get_abi(value)));
}

template <typename D> hstring consume_QGL_Projection_IContentProjectEntry<D>::FilePath() const
{
    hstring value{};
    check_hresult(WINRT_SHIM(QGL_Projection::IContentProjectEntry)->get_FilePath(put_abi(value)));
    return value;
}

template <typename D> Windows::Foundation::IAsyncAction consume_QGL_Projection_IContentProjectEntry<D>::ChangeFile(Windows::Storage::StorageFile const& newFile) const
{
    Windows::Foundation::IAsyncAction operation{ nullptr };
    check_hresult(WINRT_SHIM(QGL_Projection::IContentProjectEntry)->ChangeFile(get_abi(newFile), put_abi(operation)));
    return operation;
}

template <typename D> QGL_Projection::ContentProjectEntry consume_QGL_Projection_IContentProjectEntryFactory<D>::CreateInstance(param::hstring const& filePath, QGL_Projection::ContentInfo const& info) const
{
    QGL_Projection::ContentProjectEntry value{ nullptr };
    check_hresult(WINRT_SHIM(QGL_Projection::IContentProjectEntryFactory)->CreateInstance(get_abi(filePath), get_abi(info), put_abi(value)));
    return value;
}

template <typename D> uint16_t consume_QGL_Projection_IResourceType<D>::Value() const
{
    uint16_t value{};
    check_hresult(WINRT_SHIM(QGL_Projection::IResourceType)->get_Value(&value));
    return value;
}

template <typename D> hstring consume_QGL_Projection_IResourceType<D>::ValueName() const
{
    hstring value{};
    check_hresult(WINRT_SHIM(QGL_Projection::IResourceType)->get_ValueName(put_abi(value)));
    return value;
}

template <typename D> Windows::Foundation::Collections::IVector<QGL_Projection::ContentLoader> consume_QGL_Projection_IResourceType<D>::Loaders() const
{
    Windows::Foundation::Collections::IVector<QGL_Projection::ContentLoader> value{ nullptr };
    check_hresult(WINRT_SHIM(QGL_Projection::IResourceType)->get_Loaders(put_abi(value)));
    return value;
}

template <typename D> Windows::Foundation::Collections::IObservableVector<Windows::Foundation::IInspectable> consume_QGL_Projection_IResourceType<D>::ObservableLoaders() const
{
    Windows::Foundation::Collections::IObservableVector<Windows::Foundation::IInspectable> value{ nullptr };
    check_hresult(WINRT_SHIM(QGL_Projection::IResourceType)->get_ObservableLoaders(put_abi(value)));
    return value;
}

template <typename D> QGL_Projection::ResourceType consume_QGL_Projection_IResourceTypeFactory<D>::CreateInstance(uint16_t val, param::hstring const& name, array_view<QGL_Projection::ContentLoader const> loaders) const
{
    QGL_Projection::ResourceType value{ nullptr };
    check_hresult(WINRT_SHIM(QGL_Projection::IResourceTypeFactory)->CreateInstance(val, get_abi(name), loaders.size(), get_abi(loaders), put_abi(value)));
    return value;
}

template <typename D>
struct produce<D, QGL_Projection::ICompilerVersion> : produce_base<D, QGL_Projection::ICompilerVersion>
{
    int32_t WINRT_CALL get_Value(uint32_t* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Value, WINRT_WRAP(uint32_t));
            *value = detach_from<uint32_t>(this->shim().Value());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_ValueName(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ValueName, WINRT_WRAP(hstring));
            *value = detach_from<hstring>(this->shim().ValueName());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

template <typename D>
struct produce<D, QGL_Projection::ICompilerVersionFactory> : produce_base<D, QGL_Projection::ICompilerVersionFactory>
{
    int32_t WINRT_CALL CreateInstance(uint32_t val, void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CreateInstance, WINRT_WRAP(QGL_Projection::CompilerVersion), uint32_t);
            *value = detach_from<QGL_Projection::CompilerVersion>(this->shim().CreateInstance(val));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

template <typename D>
struct produce<D, QGL_Projection::ICompilerVersionStatics> : produce_base<D, QGL_Projection::ICompilerVersionStatics>
{
    int32_t WINRT_CALL get_Version_0_1(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Version_0_1, WINRT_WRAP(QGL_Projection::CompilerVersion));
            *value = detach_from<QGL_Projection::CompilerVersion>(this->shim().Version_0_1());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_Version_0_2(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Version_0_2, WINRT_WRAP(QGL_Projection::CompilerVersion));
            *value = detach_from<QGL_Projection::CompilerVersion>(this->shim().Version_0_2());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_CompilerVersions(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CompilerVersions, WINRT_WRAP(Windows::Foundation::Collections::IVector<QGL_Projection::CompilerVersion>));
            *value = detach_from<Windows::Foundation::Collections::IVector<QGL_Projection::CompilerVersion>>(this->shim().CompilerVersions());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_ObservableCompilerVersions(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ObservableCompilerVersions, WINRT_WRAP(Windows::Foundation::Collections::IObservableVector<Windows::Foundation::IInspectable>));
            *value = detach_from<Windows::Foundation::Collections::IObservableVector<Windows::Foundation::IInspectable>>(this->shim().ObservableCompilerVersions());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

template <typename D>
struct produce<D, QGL_Projection::IContentExtension> : produce_base<D, QGL_Projection::IContentExtension>
{
    int32_t WINRT_CALL get_ResourceType(uint16_t* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ResourceType, WINRT_WRAP(uint16_t));
            *value = detach_from<uint16_t>(this->shim().ResourceType());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_ContentLoaderID(uint16_t* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ContentLoaderID, WINRT_WRAP(uint16_t));
            *value = detach_from<uint16_t>(this->shim().ContentLoaderID());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_ContentExtension(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ContentExtension, WINRT_WRAP(hstring));
            *value = detach_from<hstring>(this->shim().ContentExtension());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_ContentLoaderName(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ContentLoaderName, WINRT_WRAP(hstring));
            *value = detach_from<hstring>(this->shim().ContentLoaderName());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_ResourceTypeName(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ResourceTypeName, WINRT_WRAP(hstring));
            *value = detach_from<hstring>(this->shim().ResourceTypeName());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL Open(void* f, void** operation) noexcept final
    {
        try
        {
            *operation = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Open, WINRT_WRAP(Windows::Foundation::IAsyncAction), Windows::Storage::StorageFile const&);
            *operation = detach_from<Windows::Foundation::IAsyncAction>(this->shim().Open(*reinterpret_cast<Windows::Storage::StorageFile const*>(&f)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL Save(void* f, void** operation) noexcept final
    {
        try
        {
            *operation = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Save, WINRT_WRAP(Windows::Foundation::IAsyncAction), Windows::Storage::StorageFile const&);
            *operation = detach_from<Windows::Foundation::IAsyncAction>(this->shim().Save(*reinterpret_cast<Windows::Storage::StorageFile const*>(&f)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

template <typename D>
struct produce<D, QGL_Projection::IContentInfo> : produce_base<D, QGL_Projection::IContentInfo>
{
    int32_t WINRT_CALL get_ContentVisible(bool* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ContentVisible, WINRT_WRAP(bool));
            *value = detach_from<bool>(this->shim().ContentVisible());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_ContentVisible(bool value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ContentVisible, WINRT_WRAP(void), bool);
            this->shim().ContentVisible(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_ContentObeyPhysics(bool* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ContentObeyPhysics, WINRT_WRAP(bool));
            *value = detach_from<bool>(this->shim().ContentObeyPhysics());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_ContentObeyPhysics(bool value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ContentObeyPhysics, WINRT_WRAP(void), bool);
            this->shim().ContentObeyPhysics(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_ContentName(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ContentName, WINRT_WRAP(hstring));
            *value = detach_from<hstring>(this->shim().ContentName());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_ContentName(void* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ContentName, WINRT_WRAP(void), hstring const&);
            this->shim().ContentName(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_ResourceType(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ResourceType, WINRT_WRAP(QGL_Projection::ResourceType));
            *value = detach_from<QGL_Projection::ResourceType>(this->shim().ResourceType());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_ResourceType(void* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ResourceType, WINRT_WRAP(void), QGL_Projection::ResourceType const&);
            this->shim().ResourceType(*reinterpret_cast<QGL_Projection::ResourceType const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_ContentLoader(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ContentLoader, WINRT_WRAP(QGL_Projection::ContentLoader));
            *value = detach_from<QGL_Projection::ContentLoader>(this->shim().ContentLoader());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_ContentLoader(void* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ContentLoader, WINRT_WRAP(void), QGL_Projection::ContentLoader const&);
            this->shim().ContentLoader(*reinterpret_cast<QGL_Projection::ContentLoader const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_CompilerVersion(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CompilerVersion, WINRT_WRAP(QGL_Projection::CompilerVersion));
            *value = detach_from<QGL_Projection::CompilerVersion>(this->shim().CompilerVersion());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_CompilerVersion(void* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CompilerVersion, WINRT_WRAP(void), QGL_Projection::CompilerVersion const&);
            this->shim().CompilerVersion(*reinterpret_cast<QGL_Projection::CompilerVersion const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL Guid(winrt::guid* result) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Guid, WINRT_WRAP(winrt::guid));
            *result = detach_from<winrt::guid>(this->shim().Guid());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL Guid2(winrt::guid g) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Guid, WINRT_WRAP(void), winrt::guid const&);
            this->shim().Guid(*reinterpret_cast<winrt::guid const*>(&g));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

template <typename D>
struct produce<D, QGL_Projection::IContentInfoStatics> : produce_base<D, QGL_Projection::IContentInfoStatics>
{
    int32_t WINRT_CALL WriteContentInfoToBuffer(void* info, void* r) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(WriteContentInfoToBuffer, WINRT_WRAP(void), QGL_Projection::ContentInfo const&, Windows::Storage::Streams::DataWriter const&);
            this->shim().WriteContentInfoToBuffer(*reinterpret_cast<QGL_Projection::ContentInfo const*>(&info), *reinterpret_cast<Windows::Storage::Streams::DataWriter const*>(&r));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL ReadContentInfoFromBuffer(void* r, void* supportedResourceTypes, void** result) noexcept final
    {
        try
        {
            *result = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ReadContentInfoFromBuffer, WINRT_WRAP(QGL_Projection::ContentInfo), Windows::Storage::Streams::DataReader const&, Windows::Foundation::Collections::IVector<QGL_Projection::ResourceType> const&);
            *result = detach_from<QGL_Projection::ContentInfo>(this->shim().ReadContentInfoFromBuffer(*reinterpret_cast<Windows::Storage::Streams::DataReader const*>(&r), *reinterpret_cast<Windows::Foundation::Collections::IVector<QGL_Projection::ResourceType> const*>(&supportedResourceTypes)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

template <typename D>
struct produce<D, QGL_Projection::IContentLoader> : produce_base<D, QGL_Projection::IContentLoader>
{
    int32_t WINRT_CALL get_Value(uint16_t* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Value, WINRT_WRAP(uint16_t));
            *value = detach_from<uint16_t>(this->shim().Value());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_ValueName(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ValueName, WINRT_WRAP(hstring));
            *value = detach_from<hstring>(this->shim().ValueName());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

template <typename D>
struct produce<D, QGL_Projection::IContentLoaderFactory> : produce_base<D, QGL_Projection::IContentLoaderFactory>
{
    int32_t WINRT_CALL CreateInstance(uint16_t val, void* name, void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CreateInstance, WINRT_WRAP(QGL_Projection::ContentLoader), uint16_t, hstring const&);
            *value = detach_from<QGL_Projection::ContentLoader>(this->shim().CreateInstance(val, *reinterpret_cast<hstring const*>(&name)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

template <typename D>
struct produce<D, QGL_Projection::IContentProject> : produce_base<D, QGL_Projection::IContentProject>
{
    int32_t WINRT_CALL get_ContentInfo(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ContentInfo, WINRT_WRAP(QGL_Projection::ContentInfo));
            *value = detach_from<QGL_Projection::ContentInfo>(this->shim().ContentInfo());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_ContentInfo(void* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ContentInfo, WINRT_WRAP(void), QGL_Projection::ContentInfo const&);
            this->shim().ContentInfo(*reinterpret_cast<QGL_Projection::ContentInfo const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_ObservableEntries(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ObservableEntries, WINRT_WRAP(Windows::Foundation::Collections::IObservableVector<Windows::Foundation::IInspectable>));
            *value = detach_from<Windows::Foundation::Collections::IObservableVector<Windows::Foundation::IInspectable>>(this->shim().ObservableEntries());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_ObservableEntries(void* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ObservableEntries, WINRT_WRAP(void), Windows::Foundation::Collections::IObservableVector<Windows::Foundation::IInspectable> const&);
            this->shim().ObservableEntries(*reinterpret_cast<Windows::Foundation::Collections::IObservableVector<Windows::Foundation::IInspectable> const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL LoadFromFileAsync(void* f, void* supported, void** operation) noexcept final
    {
        try
        {
            *operation = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(LoadFromFileAsync, WINRT_WRAP(Windows::Foundation::IAsyncOperation<bool>), Windows::Storage::StorageFile const, Windows::Foundation::Collections::IVector<QGL_Projection::ResourceType> const);
            *operation = detach_from<Windows::Foundation::IAsyncOperation<bool>>(this->shim().LoadFromFileAsync(*reinterpret_cast<Windows::Storage::StorageFile const*>(&f), *reinterpret_cast<Windows::Foundation::Collections::IVector<QGL_Projection::ResourceType> const*>(&supported)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL SaveToFileAsync(void* f, void** operation) noexcept final
    {
        try
        {
            *operation = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(SaveToFileAsync, WINRT_WRAP(Windows::Foundation::IAsyncOperation<bool>), Windows::Storage::StorageFile const);
            *operation = detach_from<Windows::Foundation::IAsyncOperation<bool>>(this->shim().SaveToFileAsync(*reinterpret_cast<Windows::Storage::StorageFile const*>(&f)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

template <typename D>
struct produce<D, QGL_Projection::IContentProjectEntry> : produce_base<D, QGL_Projection::IContentProjectEntry>
{
    int32_t WINRT_CALL get_ContentInfo(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ContentInfo, WINRT_WRAP(QGL_Projection::ContentInfo));
            *value = detach_from<QGL_Projection::ContentInfo>(this->shim().ContentInfo());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_ContentInfo(void* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ContentInfo, WINRT_WRAP(void), QGL_Projection::ContentInfo const&);
            this->shim().ContentInfo(*reinterpret_cast<QGL_Projection::ContentInfo const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_FilePath(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(FilePath, WINRT_WRAP(hstring));
            *value = detach_from<hstring>(this->shim().FilePath());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL ChangeFile(void* newFile, void** operation) noexcept final
    {
        try
        {
            *operation = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ChangeFile, WINRT_WRAP(Windows::Foundation::IAsyncAction), Windows::Storage::StorageFile const&);
            *operation = detach_from<Windows::Foundation::IAsyncAction>(this->shim().ChangeFile(*reinterpret_cast<Windows::Storage::StorageFile const*>(&newFile)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

template <typename D>
struct produce<D, QGL_Projection::IContentProjectEntryFactory> : produce_base<D, QGL_Projection::IContentProjectEntryFactory>
{
    int32_t WINRT_CALL CreateInstance(void* filePath, void* info, void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CreateInstance, WINRT_WRAP(QGL_Projection::ContentProjectEntry), hstring const&, QGL_Projection::ContentInfo const&);
            *value = detach_from<QGL_Projection::ContentProjectEntry>(this->shim().CreateInstance(*reinterpret_cast<hstring const*>(&filePath), *reinterpret_cast<QGL_Projection::ContentInfo const*>(&info)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

template <typename D>
struct produce<D, QGL_Projection::IResourceType> : produce_base<D, QGL_Projection::IResourceType>
{
    int32_t WINRT_CALL get_Value(uint16_t* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Value, WINRT_WRAP(uint16_t));
            *value = detach_from<uint16_t>(this->shim().Value());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_ValueName(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ValueName, WINRT_WRAP(hstring));
            *value = detach_from<hstring>(this->shim().ValueName());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_Loaders(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Loaders, WINRT_WRAP(Windows::Foundation::Collections::IVector<QGL_Projection::ContentLoader>));
            *value = detach_from<Windows::Foundation::Collections::IVector<QGL_Projection::ContentLoader>>(this->shim().Loaders());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_ObservableLoaders(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ObservableLoaders, WINRT_WRAP(Windows::Foundation::Collections::IObservableVector<Windows::Foundation::IInspectable>));
            *value = detach_from<Windows::Foundation::Collections::IObservableVector<Windows::Foundation::IInspectable>>(this->shim().ObservableLoaders());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

template <typename D>
struct produce<D, QGL_Projection::IResourceTypeFactory> : produce_base<D, QGL_Projection::IResourceTypeFactory>
{
    int32_t WINRT_CALL CreateInstance(uint16_t val, void* name, uint32_t __loadersSize, void** loaders, void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CreateInstance, WINRT_WRAP(QGL_Projection::ResourceType), uint16_t, hstring const&, array_view<QGL_Projection::ContentLoader const>);
            *value = detach_from<QGL_Projection::ResourceType>(this->shim().CreateInstance(val, *reinterpret_cast<hstring const*>(&name), array_view<QGL_Projection::ContentLoader const>(reinterpret_cast<QGL_Projection::ContentLoader const *>(loaders), reinterpret_cast<QGL_Projection::ContentLoader const *>(loaders) + __loadersSize)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

}

WINRT_EXPORT namespace winrt::QGL_Projection {

inline CompilerVersion::CompilerVersion(uint32_t val) :
    CompilerVersion(impl::call_factory<CompilerVersion, QGL_Projection::ICompilerVersionFactory>([&](auto&& f) { return f.CreateInstance(val); }))
{}

inline QGL_Projection::CompilerVersion CompilerVersion::Version_0_1()
{
    return impl::call_factory<CompilerVersion, QGL_Projection::ICompilerVersionStatics>([&](auto&& f) { return f.Version_0_1(); });
}

inline QGL_Projection::CompilerVersion CompilerVersion::Version_0_2()
{
    return impl::call_factory<CompilerVersion, QGL_Projection::ICompilerVersionStatics>([&](auto&& f) { return f.Version_0_2(); });
}

inline Windows::Foundation::Collections::IVector<QGL_Projection::CompilerVersion> CompilerVersion::CompilerVersions()
{
    return impl::call_factory<CompilerVersion, QGL_Projection::ICompilerVersionStatics>([&](auto&& f) { return f.CompilerVersions(); });
}

inline Windows::Foundation::Collections::IObservableVector<Windows::Foundation::IInspectable> CompilerVersion::ObservableCompilerVersions()
{
    return impl::call_factory<CompilerVersion, QGL_Projection::ICompilerVersionStatics>([&](auto&& f) { return f.ObservableCompilerVersions(); });
}

inline ContentInfo::ContentInfo() :
    ContentInfo(impl::call_factory<ContentInfo>([](auto&& f) { return f.template ActivateInstance<ContentInfo>(); }))
{}

inline void ContentInfo::WriteContentInfoToBuffer(QGL_Projection::ContentInfo const& info, Windows::Storage::Streams::DataWriter const& r)
{
    impl::call_factory<ContentInfo, QGL_Projection::IContentInfoStatics>([&](auto&& f) { return f.WriteContentInfoToBuffer(info, r); });
}

inline QGL_Projection::ContentInfo ContentInfo::ReadContentInfoFromBuffer(Windows::Storage::Streams::DataReader const& r, param::vector<QGL_Projection::ResourceType> const& supportedResourceTypes)
{
    return impl::call_factory<ContentInfo, QGL_Projection::IContentInfoStatics>([&](auto&& f) { return f.ReadContentInfoFromBuffer(r, supportedResourceTypes); });
}

inline ContentLoader::ContentLoader(uint16_t val, param::hstring const& name) :
    ContentLoader(impl::call_factory<ContentLoader, QGL_Projection::IContentLoaderFactory>([&](auto&& f) { return f.CreateInstance(val, name); }))
{}

inline ContentProject::ContentProject() :
    ContentProject(impl::call_factory<ContentProject>([](auto&& f) { return f.template ActivateInstance<ContentProject>(); }))
{}

inline ContentProjectEntry::ContentProjectEntry(param::hstring const& filePath, QGL_Projection::ContentInfo const& info) :
    ContentProjectEntry(impl::call_factory<ContentProjectEntry, QGL_Projection::IContentProjectEntryFactory>([&](auto&& f) { return f.CreateInstance(filePath, info); }))
{}

inline ResourceType::ResourceType(uint16_t val, param::hstring const& name, array_view<QGL_Projection::ContentLoader const> loaders) :
    ResourceType(impl::call_factory<ResourceType, QGL_Projection::IResourceTypeFactory>([&](auto&& f) { return f.CreateInstance(val, name, loaders); }))
{}

}

namespace winrt::impl {

struct property_QGL_Projection_ICompilerVersion
{ struct named {
    struct Value
    {
        struct name { static constexpr std::wstring_view value{ L"Value"sv }; };
        using property_type = uint32_t;
        using target_type = winrt::QGL_Projection::ICompilerVersion;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.Value();
            }
        };
    };
    struct ValueName
    {
        struct name { static constexpr std::wstring_view value{ L"ValueName"sv }; };
        using property_type = winrt::hstring;
        using target_type = winrt::QGL_Projection::ICompilerVersion;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.ValueName();
            }
        };
    };};
    struct list { using type = impl::typelist<named::Value, named::ValueName>; };
};

struct property_QGL_Projection_ICompilerVersionStatics
{ struct named {
    struct CompilerVersions
    {
        struct name { static constexpr std::wstring_view value{ L"CompilerVersions"sv }; };
        using property_type = winrt::Windows::Foundation::Collections::IVector<QGL_Projection::CompilerVersion>;
        using target_type = winrt::QGL_Projection::ICompilerVersionStatics;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.CompilerVersions();
            }
        };
    };
    struct ObservableCompilerVersions
    {
        struct name { static constexpr std::wstring_view value{ L"ObservableCompilerVersions"sv }; };
        using property_type = winrt::Windows::Foundation::Collections::IObservableVector<Windows::Foundation::IInspectable>;
        using target_type = winrt::QGL_Projection::ICompilerVersionStatics;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.ObservableCompilerVersions();
            }
        };
    };
    struct Version_0_1
    {
        struct name { static constexpr std::wstring_view value{ L"Version_0_1"sv }; };
        using property_type = winrt::QGL_Projection::CompilerVersion;
        using target_type = winrt::QGL_Projection::ICompilerVersionStatics;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.Version_0_1();
            }
        };
    };
    struct Version_0_2
    {
        struct name { static constexpr std::wstring_view value{ L"Version_0_2"sv }; };
        using property_type = winrt::QGL_Projection::CompilerVersion;
        using target_type = winrt::QGL_Projection::ICompilerVersionStatics;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.Version_0_2();
            }
        };
    };};
    struct list { using type = impl::typelist<named::CompilerVersions, named::ObservableCompilerVersions, named::Version_0_1, named::Version_0_2>; };
};

struct property_QGL_Projection_IContentExtension
{ struct named {
    struct ContentExtension
    {
        struct name { static constexpr std::wstring_view value{ L"ContentExtension"sv }; };
        using property_type = winrt::hstring;
        using target_type = winrt::QGL_Projection::IContentExtension;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.ContentExtension();
            }
        };
    };
    struct ContentLoaderID
    {
        struct name { static constexpr std::wstring_view value{ L"ContentLoaderID"sv }; };
        using property_type = uint16_t;
        using target_type = winrt::QGL_Projection::IContentExtension;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.ContentLoaderID();
            }
        };
    };
    struct ContentLoaderName
    {
        struct name { static constexpr std::wstring_view value{ L"ContentLoaderName"sv }; };
        using property_type = winrt::hstring;
        using target_type = winrt::QGL_Projection::IContentExtension;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.ContentLoaderName();
            }
        };
    };
    struct ResourceType
    {
        struct name { static constexpr std::wstring_view value{ L"ResourceType"sv }; };
        using property_type = uint16_t;
        using target_type = winrt::QGL_Projection::IContentExtension;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.ResourceType();
            }
        };
    };
    struct ResourceTypeName
    {
        struct name { static constexpr std::wstring_view value{ L"ResourceTypeName"sv }; };
        using property_type = winrt::hstring;
        using target_type = winrt::QGL_Projection::IContentExtension;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.ResourceTypeName();
            }
        };
    };};
    struct list { using type = impl::typelist<named::ContentExtension, named::ContentLoaderID, named::ContentLoaderName, named::ResourceType, named::ResourceTypeName>; };
};

struct property_QGL_Projection_IContentInfo
{ struct named {
    struct CompilerVersion
    {
        struct name { static constexpr std::wstring_view value{ L"CompilerVersion"sv }; };
        using property_type = winrt::QGL_Projection::CompilerVersion;
        using target_type = winrt::QGL_Projection::IContentInfo;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.CompilerVersion();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.CompilerVersion(std::forward<Value>(value));
            }
        };
    };
    struct ContentLoader
    {
        struct name { static constexpr std::wstring_view value{ L"ContentLoader"sv }; };
        using property_type = winrt::QGL_Projection::ContentLoader;
        using target_type = winrt::QGL_Projection::IContentInfo;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.ContentLoader();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.ContentLoader(std::forward<Value>(value));
            }
        };
    };
    struct ContentName
    {
        struct name { static constexpr std::wstring_view value{ L"ContentName"sv }; };
        using property_type = winrt::hstring;
        using target_type = winrt::QGL_Projection::IContentInfo;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.ContentName();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.ContentName(std::forward<Value>(value));
            }
        };
    };
    struct ContentObeyPhysics
    {
        struct name { static constexpr std::wstring_view value{ L"ContentObeyPhysics"sv }; };
        using property_type = bool;
        using target_type = winrt::QGL_Projection::IContentInfo;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.ContentObeyPhysics();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.ContentObeyPhysics(std::forward<Value>(value));
            }
        };
    };
    struct ContentVisible
    {
        struct name { static constexpr std::wstring_view value{ L"ContentVisible"sv }; };
        using property_type = bool;
        using target_type = winrt::QGL_Projection::IContentInfo;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.ContentVisible();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.ContentVisible(std::forward<Value>(value));
            }
        };
    };
    struct ResourceType
    {
        struct name { static constexpr std::wstring_view value{ L"ResourceType"sv }; };
        using property_type = winrt::QGL_Projection::ResourceType;
        using target_type = winrt::QGL_Projection::IContentInfo;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.ResourceType();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.ResourceType(std::forward<Value>(value));
            }
        };
    };};
    struct list { using type = impl::typelist<named::CompilerVersion, named::ContentLoader, named::ContentName, named::ContentObeyPhysics, named::ContentVisible, named::ResourceType>; };
};

struct property_QGL_Projection_IContentLoader
{ struct named {
    struct Value
    {
        struct name { static constexpr std::wstring_view value{ L"Value"sv }; };
        using property_type = uint16_t;
        using target_type = winrt::QGL_Projection::IContentLoader;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.Value();
            }
        };
    };
    struct ValueName
    {
        struct name { static constexpr std::wstring_view value{ L"ValueName"sv }; };
        using property_type = winrt::hstring;
        using target_type = winrt::QGL_Projection::IContentLoader;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.ValueName();
            }
        };
    };};
    struct list { using type = impl::typelist<named::Value, named::ValueName>; };
};

struct property_QGL_Projection_IContentProject
{ struct named {
    struct ContentInfo
    {
        struct name { static constexpr std::wstring_view value{ L"ContentInfo"sv }; };
        using property_type = winrt::QGL_Projection::ContentInfo;
        using target_type = winrt::QGL_Projection::IContentProject;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.ContentInfo();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.ContentInfo(std::forward<Value>(value));
            }
        };
    };
    struct ObservableEntries
    {
        struct name { static constexpr std::wstring_view value{ L"ObservableEntries"sv }; };
        using property_type = winrt::Windows::Foundation::Collections::IObservableVector<Windows::Foundation::IInspectable>;
        using target_type = winrt::QGL_Projection::IContentProject;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.ObservableEntries();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.ObservableEntries(std::forward<Value>(value));
            }
        };
    };};
    struct list { using type = impl::typelist<named::ContentInfo, named::ObservableEntries>; };
};

struct property_QGL_Projection_IContentProjectEntry
{ struct named {
    struct ContentInfo
    {
        struct name { static constexpr std::wstring_view value{ L"ContentInfo"sv }; };
        using property_type = winrt::QGL_Projection::ContentInfo;
        using target_type = winrt::QGL_Projection::IContentProjectEntry;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.ContentInfo();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.ContentInfo(std::forward<Value>(value));
            }
        };
    };
    struct FilePath
    {
        struct name { static constexpr std::wstring_view value{ L"FilePath"sv }; };
        using property_type = winrt::hstring;
        using target_type = winrt::QGL_Projection::IContentProjectEntry;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.FilePath();
            }
        };
    };};
    struct list { using type = impl::typelist<named::ContentInfo, named::FilePath>; };
};

struct property_QGL_Projection_IResourceType
{ struct named {
    struct Loaders
    {
        struct name { static constexpr std::wstring_view value{ L"Loaders"sv }; };
        using property_type = winrt::Windows::Foundation::Collections::IVector<QGL_Projection::ContentLoader>;
        using target_type = winrt::QGL_Projection::IResourceType;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.Loaders();
            }
        };
    };
    struct ObservableLoaders
    {
        struct name { static constexpr std::wstring_view value{ L"ObservableLoaders"sv }; };
        using property_type = winrt::Windows::Foundation::Collections::IObservableVector<Windows::Foundation::IInspectable>;
        using target_type = winrt::QGL_Projection::IResourceType;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.ObservableLoaders();
            }
        };
    };
    struct Value
    {
        struct name { static constexpr std::wstring_view value{ L"Value"sv }; };
        using property_type = uint16_t;
        using target_type = winrt::QGL_Projection::IResourceType;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.Value();
            }
        };
    };
    struct ValueName
    {
        struct name { static constexpr std::wstring_view value{ L"ValueName"sv }; };
        using property_type = winrt::hstring;
        using target_type = winrt::QGL_Projection::IResourceType;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.ValueName();
            }
        };
    };};
    struct list { using type = impl::typelist<named::Loaders, named::ObservableLoaders, named::Value, named::ValueName>; };
};

struct property_QGL_Projection_CompilerVersion
{ struct named {
    struct Value
    {
        struct name { static constexpr std::wstring_view value{ L"Value"sv }; };
        using property_type = uint32_t;
        using target_type = winrt::QGL_Projection::CompilerVersion;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.Value();
            }
        };
    };
    struct ValueName
    {
        struct name { static constexpr std::wstring_view value{ L"ValueName"sv }; };
        using property_type = winrt::hstring;
        using target_type = winrt::QGL_Projection::CompilerVersion;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.ValueName();
            }
        };
    };
    struct CompilerVersions
    {
        struct name { static constexpr std::wstring_view value{ L"CompilerVersions"sv }; };
        using property_type = winrt::Windows::Foundation::Collections::IVector<QGL_Projection::CompilerVersion>;
        using target_type = winrt::QGL_Projection::CompilerVersion;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::true_type;
        struct getter
        {
            auto operator()() const
            {
                return target_type::CompilerVersions();
            }
        };
    };
    struct ObservableCompilerVersions
    {
        struct name { static constexpr std::wstring_view value{ L"ObservableCompilerVersions"sv }; };
        using property_type = winrt::Windows::Foundation::Collections::IObservableVector<Windows::Foundation::IInspectable>;
        using target_type = winrt::QGL_Projection::CompilerVersion;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::true_type;
        struct getter
        {
            auto operator()() const
            {
                return target_type::ObservableCompilerVersions();
            }
        };
    };
    struct Version_0_1
    {
        struct name { static constexpr std::wstring_view value{ L"Version_0_1"sv }; };
        using property_type = winrt::QGL_Projection::CompilerVersion;
        using target_type = winrt::QGL_Projection::CompilerVersion;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::true_type;
        struct getter
        {
            auto operator()() const
            {
                return target_type::Version_0_1();
            }
        };
    };
    struct Version_0_2
    {
        struct name { static constexpr std::wstring_view value{ L"Version_0_2"sv }; };
        using property_type = winrt::QGL_Projection::CompilerVersion;
        using target_type = winrt::QGL_Projection::CompilerVersion;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::true_type;
        struct getter
        {
            auto operator()() const
            {
                return target_type::Version_0_2();
            }
        };
    };};
    struct list { using type = impl::typelist<named::Value, named::ValueName, named::CompilerVersions, named::ObservableCompilerVersions, named::Version_0_1, named::Version_0_2>; };
};

struct property_QGL_Projection_ContentInfo
{ struct named {
    struct ResourceType
    {
        struct name { static constexpr std::wstring_view value{ L"ResourceType"sv }; };
        using property_type = winrt::QGL_Projection::ResourceType;
        using target_type = winrt::QGL_Projection::ContentInfo;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.ResourceType();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.ResourceType(std::forward<Value>(value));
            }
        };
    };
    struct ContentVisible
    {
        struct name { static constexpr std::wstring_view value{ L"ContentVisible"sv }; };
        using property_type = bool;
        using target_type = winrt::QGL_Projection::ContentInfo;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.ContentVisible();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.ContentVisible(std::forward<Value>(value));
            }
        };
    };
    struct ContentObeyPhysics
    {
        struct name { static constexpr std::wstring_view value{ L"ContentObeyPhysics"sv }; };
        using property_type = bool;
        using target_type = winrt::QGL_Projection::ContentInfo;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.ContentObeyPhysics();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.ContentObeyPhysics(std::forward<Value>(value));
            }
        };
    };
    struct ContentName
    {
        struct name { static constexpr std::wstring_view value{ L"ContentName"sv }; };
        using property_type = winrt::hstring;
        using target_type = winrt::QGL_Projection::ContentInfo;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.ContentName();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.ContentName(std::forward<Value>(value));
            }
        };
    };
    struct ContentLoader
    {
        struct name { static constexpr std::wstring_view value{ L"ContentLoader"sv }; };
        using property_type = winrt::QGL_Projection::ContentLoader;
        using target_type = winrt::QGL_Projection::ContentInfo;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.ContentLoader();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.ContentLoader(std::forward<Value>(value));
            }
        };
    };
    struct CompilerVersion
    {
        struct name { static constexpr std::wstring_view value{ L"CompilerVersion"sv }; };
        using property_type = winrt::QGL_Projection::CompilerVersion;
        using target_type = winrt::QGL_Projection::ContentInfo;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.CompilerVersion();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.CompilerVersion(std::forward<Value>(value));
            }
        };
    };};
    struct list { using type = impl::typelist<named::ResourceType, named::ContentVisible, named::ContentObeyPhysics, named::ContentName, named::ContentLoader, named::CompilerVersion>; };
};

struct property_QGL_Projection_ContentLoader
{ struct named {
    struct Value
    {
        struct name { static constexpr std::wstring_view value{ L"Value"sv }; };
        using property_type = uint16_t;
        using target_type = winrt::QGL_Projection::ContentLoader;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.Value();
            }
        };
    };
    struct ValueName
    {
        struct name { static constexpr std::wstring_view value{ L"ValueName"sv }; };
        using property_type = winrt::hstring;
        using target_type = winrt::QGL_Projection::ContentLoader;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.ValueName();
            }
        };
    };};
    struct list { using type = impl::typelist<named::Value, named::ValueName>; };
};

struct property_QGL_Projection_ContentProject
{ struct named {
    struct ObservableEntries
    {
        struct name { static constexpr std::wstring_view value{ L"ObservableEntries"sv }; };
        using property_type = winrt::Windows::Foundation::Collections::IObservableVector<Windows::Foundation::IInspectable>;
        using target_type = winrt::QGL_Projection::ContentProject;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.ObservableEntries();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.ObservableEntries(std::forward<Value>(value));
            }
        };
    };
    struct ContentInfo
    {
        struct name { static constexpr std::wstring_view value{ L"ContentInfo"sv }; };
        using property_type = winrt::QGL_Projection::ContentInfo;
        using target_type = winrt::QGL_Projection::ContentProject;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.ContentInfo();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.ContentInfo(std::forward<Value>(value));
            }
        };
    };};
    struct list { using type = impl::typelist<named::ObservableEntries, named::ContentInfo>; };
};

struct property_QGL_Projection_ContentProjectEntry
{ struct named {
    struct ContentInfo
    {
        struct name { static constexpr std::wstring_view value{ L"ContentInfo"sv }; };
        using property_type = winrt::QGL_Projection::ContentInfo;
        using target_type = winrt::QGL_Projection::ContentProjectEntry;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.ContentInfo();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.ContentInfo(std::forward<Value>(value));
            }
        };
    };
    struct FilePath
    {
        struct name { static constexpr std::wstring_view value{ L"FilePath"sv }; };
        using property_type = winrt::hstring;
        using target_type = winrt::QGL_Projection::ContentProjectEntry;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.FilePath();
            }
        };
    };};
    struct list { using type = impl::typelist<named::ContentInfo, named::FilePath>; };
};

struct property_QGL_Projection_ResourceType
{ struct named {
    struct Loaders
    {
        struct name { static constexpr std::wstring_view value{ L"Loaders"sv }; };
        using property_type = winrt::Windows::Foundation::Collections::IVector<QGL_Projection::ContentLoader>;
        using target_type = winrt::QGL_Projection::ResourceType;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.Loaders();
            }
        };
    };
    struct ObservableLoaders
    {
        struct name { static constexpr std::wstring_view value{ L"ObservableLoaders"sv }; };
        using property_type = winrt::Windows::Foundation::Collections::IObservableVector<Windows::Foundation::IInspectable>;
        using target_type = winrt::QGL_Projection::ResourceType;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.ObservableLoaders();
            }
        };
    };
    struct Value
    {
        struct name { static constexpr std::wstring_view value{ L"Value"sv }; };
        using property_type = uint16_t;
        using target_type = winrt::QGL_Projection::ResourceType;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.Value();
            }
        };
    };
    struct ValueName
    {
        struct name { static constexpr std::wstring_view value{ L"ValueName"sv }; };
        using property_type = winrt::hstring;
        using target_type = winrt::QGL_Projection::ResourceType;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.ValueName();
            }
        };
    };};
    struct list { using type = impl::typelist<named::Loaders, named::ObservableLoaders, named::Value, named::ValueName>; };
};

}

WINRT_EXPORT namespace winrt::experimental::reflect {
template <> struct named_property<QGL_Projection::ICompilerVersion> : impl::property_QGL_Projection_ICompilerVersion::named {};
template <> struct properties<QGL_Projection::ICompilerVersion> : impl::property_QGL_Projection_ICompilerVersion::list {};
template <> struct named_property<QGL_Projection::ICompilerVersionStatics> : impl::property_QGL_Projection_ICompilerVersionStatics::named {};
template <> struct properties<QGL_Projection::ICompilerVersionStatics> : impl::property_QGL_Projection_ICompilerVersionStatics::list {};
template <> struct named_property<QGL_Projection::IContentExtension> : impl::property_QGL_Projection_IContentExtension::named {};
template <> struct properties<QGL_Projection::IContentExtension> : impl::property_QGL_Projection_IContentExtension::list {};
template <> struct named_property<QGL_Projection::IContentInfo> : impl::property_QGL_Projection_IContentInfo::named {};
template <> struct properties<QGL_Projection::IContentInfo> : impl::property_QGL_Projection_IContentInfo::list {};
template <> struct named_property<QGL_Projection::IContentLoader> : impl::property_QGL_Projection_IContentLoader::named {};
template <> struct properties<QGL_Projection::IContentLoader> : impl::property_QGL_Projection_IContentLoader::list {};
template <> struct named_property<QGL_Projection::IContentProject> : impl::property_QGL_Projection_IContentProject::named {};
template <> struct properties<QGL_Projection::IContentProject> : impl::property_QGL_Projection_IContentProject::list {};
template <> struct named_property<QGL_Projection::IContentProjectEntry> : impl::property_QGL_Projection_IContentProjectEntry::named {};
template <> struct properties<QGL_Projection::IContentProjectEntry> : impl::property_QGL_Projection_IContentProjectEntry::list {};
template <> struct named_property<QGL_Projection::IResourceType> : impl::property_QGL_Projection_IResourceType::named {};
template <> struct properties<QGL_Projection::IResourceType> : impl::property_QGL_Projection_IResourceType::list {};
template <> struct named_property<QGL_Projection::CompilerVersion> : impl::property_QGL_Projection_CompilerVersion::named {};
template <> struct properties<QGL_Projection::CompilerVersion> : impl::property_QGL_Projection_CompilerVersion::list {};
template <> struct named_property<QGL_Projection::ContentInfo> : impl::property_QGL_Projection_ContentInfo::named {};
template <> struct properties<QGL_Projection::ContentInfo> : impl::property_QGL_Projection_ContentInfo::list {};
template <> struct named_property<QGL_Projection::ContentLoader> : impl::property_QGL_Projection_ContentLoader::named {};
template <> struct properties<QGL_Projection::ContentLoader> : impl::property_QGL_Projection_ContentLoader::list {};
template <> struct named_property<QGL_Projection::ContentProject> : impl::property_QGL_Projection_ContentProject::named {};
template <> struct properties<QGL_Projection::ContentProject> : impl::property_QGL_Projection_ContentProject::list {};
template <> struct named_property<QGL_Projection::ContentProjectEntry> : impl::property_QGL_Projection_ContentProjectEntry::named {};
template <> struct properties<QGL_Projection::ContentProjectEntry> : impl::property_QGL_Projection_ContentProjectEntry::list {};
template <> struct named_property<QGL_Projection::ResourceType> : impl::property_QGL_Projection_ResourceType::named {};
template <> struct properties<QGL_Projection::ResourceType> : impl::property_QGL_Projection_ResourceType::list {};

}

WINRT_EXPORT namespace std {

template<> struct hash<winrt::QGL_Projection::ICompilerVersion> : winrt::impl::hash_base<winrt::QGL_Projection::ICompilerVersion> {};
template<> struct hash<winrt::QGL_Projection::ICompilerVersionFactory> : winrt::impl::hash_base<winrt::QGL_Projection::ICompilerVersionFactory> {};
template<> struct hash<winrt::QGL_Projection::ICompilerVersionStatics> : winrt::impl::hash_base<winrt::QGL_Projection::ICompilerVersionStatics> {};
template<> struct hash<winrt::QGL_Projection::IContentExtension> : winrt::impl::hash_base<winrt::QGL_Projection::IContentExtension> {};
template<> struct hash<winrt::QGL_Projection::IContentInfo> : winrt::impl::hash_base<winrt::QGL_Projection::IContentInfo> {};
template<> struct hash<winrt::QGL_Projection::IContentInfoStatics> : winrt::impl::hash_base<winrt::QGL_Projection::IContentInfoStatics> {};
template<> struct hash<winrt::QGL_Projection::IContentLoader> : winrt::impl::hash_base<winrt::QGL_Projection::IContentLoader> {};
template<> struct hash<winrt::QGL_Projection::IContentLoaderFactory> : winrt::impl::hash_base<winrt::QGL_Projection::IContentLoaderFactory> {};
template<> struct hash<winrt::QGL_Projection::IContentProject> : winrt::impl::hash_base<winrt::QGL_Projection::IContentProject> {};
template<> struct hash<winrt::QGL_Projection::IContentProjectEntry> : winrt::impl::hash_base<winrt::QGL_Projection::IContentProjectEntry> {};
template<> struct hash<winrt::QGL_Projection::IContentProjectEntryFactory> : winrt::impl::hash_base<winrt::QGL_Projection::IContentProjectEntryFactory> {};
template<> struct hash<winrt::QGL_Projection::IResourceType> : winrt::impl::hash_base<winrt::QGL_Projection::IResourceType> {};
template<> struct hash<winrt::QGL_Projection::IResourceTypeFactory> : winrt::impl::hash_base<winrt::QGL_Projection::IResourceTypeFactory> {};
template<> struct hash<winrt::QGL_Projection::CompilerVersion> : winrt::impl::hash_base<winrt::QGL_Projection::CompilerVersion> {};
template<> struct hash<winrt::QGL_Projection::ContentInfo> : winrt::impl::hash_base<winrt::QGL_Projection::ContentInfo> {};
template<> struct hash<winrt::QGL_Projection::ContentLoader> : winrt::impl::hash_base<winrt::QGL_Projection::ContentLoader> {};
template<> struct hash<winrt::QGL_Projection::ContentProject> : winrt::impl::hash_base<winrt::QGL_Projection::ContentProject> {};
template<> struct hash<winrt::QGL_Projection::ContentProjectEntry> : winrt::impl::hash_base<winrt::QGL_Projection::ContentProjectEntry> {};
template<> struct hash<winrt::QGL_Projection::ResourceType> : winrt::impl::hash_base<winrt::QGL_Projection::ResourceType> {};

}
